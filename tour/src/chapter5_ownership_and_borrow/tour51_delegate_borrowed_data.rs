struct Foo {
    x: i32,
}

fn do_something(f: &mut Foo) {
    f.x += 1;
    // f への可変な参照はここでドロップ
}

/*
Rustの参照に関するルールは、以下のようにまとめられます。
* Rustでは、可変な参照が一つだけか、普遍な参照が複数かのどちらかが許可されます。
  両方を同時には使用できません。
* 参照は、所有者よりも長く存在してはなりません。

これは、関数への参照を渡す際に問題となることはありません。

メモリの詳細:
 * 参照の最初のルールはデータ競合を防ぎます。
   データ競合とは？データを読み込む際、データへの書き込みが同時に行われると、
   同期が取れなくなる可能性があります。
 * 参照の二番目のルールは、存在しないデータへの参照(C言語ではダングリングポインタと呼ばれる) による誤動作を防ぐためのものです。

*/
fn main() {
    let mut foo = Foo { x: 42 };
    println!("{}", foo.x); //42

    do_something(&mut foo); // foo の可変参照を貸したが、 do_somethingの中でdropしているので、
    println!("{}", foo.x); //43

    // また参照できちゃう
    do_something(&mut foo);
    println!("{}", foo.x); //44
}
