fn main() {
    // 所有権とは
    let s = "Hello"; // コンパイル時にメモリがスタックに積まれる
    println!("{}", s);

    // 伸長可能なテキスト片。実行されると、OSにメモリを要求する。ヒープ。
    let mut s = String::from("Hello dayo");
    println!("{}", s);
    s.push_str("hoge piyo dappi");
    println!("{}", s);

    /*
    ## プログラミングはOSとおしゃべりしてリソースを借りたり返したりするもの
    基本的な考え型として、OSから割り当てられたメモリを開放する役割は、アプリ側が担わなければならない。
    なので、メモリ要求とメモリ解放は、本来というか大前提として、借りたら返す。当たり前だね。
    N回メモリを要求したら、N回メモリを解放しないといけない。
    N-1回のメモリ解放でも、N+1回のメモリ解放でもだめ。
    ちょうど、 一対一の関係ででなければならない…が、それが難しい。

    ## 全てのメモリの面倒を人間(プログラマ)が見る世界
    本当にこのメモリって開放してもいいのかな？他にまだ使う人がいないかな？
    開放が早すぎると、無効な変数を使ってしまうし、
    開放がおそすぎると(忘れてしまうと)、メモリを無駄にしてしまう。
    もう絶対に誰からも使われない、ということを担保して、ただの一度だけメモリを解放しないと行けない。

    難しそうだよね。
    僕なら、解放していいのかどうかわからない変数を見つけたら、
    僕じゃない誰かが解放してくれることを期待して、メモリ解放は行わないことにするよ。

    だって下手にメモリ解放をしてN:Nの均衡がくずれちゃったら怖いからね。

    ## メモリリークとは
    そうやって、本当はもう使わなくなったメモリなんだけれど、全ての人間から忘れ去られて放置されてしまったメモリを、メモリリークと言います。

    ちょっとしたプログラムなら良いけれど、ソフトウェアの複雑性が増すにつれて、
    「このメモリって解放していいんだよな…？」の判断を人間風情が下すのは難しくなっていくのは、なんとなく想像ができるんじゃないだろうか。

    ## ガベージコレクション
    そこで、LISP開発者であるジョン・マッカーシーは、この問題を緩和するために、
    プログラムが動的に確保したメモリ領域のうち、不要になった領域を自動的に開放する機能を開発した。

    それがガベージコレクション。どこからも参照されていないメモリ領域を自動的に解放する仕組み。
    これによって、プログラマはメモリを要求する記述をした回数だけ、メモリを開放する記述をしなければならない苦行から一部開放された。
    借りたら借りっぱなしでOK.返却はGCがやってくれるっす！ｗ

    ちなみにLISPはにて、木構造、ガベージコレクション、動的型付け、
    条件分岐、高階関数、再帰、セルフホスティング、コンパイラを含む多くのアイディアを切り開いた言語であり、計算機科学的に意義深い貢献をしている。
    ジョン・マッカーシー、偉大な人なんです。

    ## GCのふたつの問題
    プログラミング言語がGCをサポートしていれば、メモリリークは決して起こらない。やったー！なのだろうか？残念ながらそうではない。
    ひとつは、GCは全メモリ空間を監視しないと行けないので、処理に時間がかかってしまう(オーバーヘッド)。
    また、監視にあたってメモリの静止点をつくらなければならない。

    もうひとつは、ガベージコレクタは、全てのメモリを「ごみ」という扱いにできるわけではない。彼らが収集できるメモリと、収集できないメモリを見分けているのである。
    「ごみ」になるメモリは弱い参照(Weak Ref)といって、GCの回収対象になってしまう。

    ごみにならないメモリは強い参照(たんに参照とも)といって、GCの対象とはならない。
    なので、この部分は自分でメモリを解放しなければ、メモリリークが発生する可能性があるということ。

    [出典]
    - https://en.wikipedia.org/wiki/Memory_management
    - https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF
    - https://ja.wikipedia.org/wiki/%E3%82%B8%E3%83%A7%E3%83%B3%E3%83%BB%E3%83%9E%E3%83%83%E3%82%AB%E3%83%BC%E3%82%B7%E3%83%BC
    - https://ja.wikipedia.org/wiki/%E5%BC%B1%E3%81%84%E5%8F%82%E7%85%A7
    - https://en.wikipedia.org/wiki/Weak_reference
    - https://www.fujitsu.com/jp/documents/products/software/resources/technical/interstage/apserver/guide/reference-gc.pdf

    ---

    Rustは、メモリを借りて、メモリを返す手段として、プログラマがallocate and free　を頑張るのでも、GCでもない方法を実現しています。

    Rustは、変数がスコープを抜けると、自然とメモリを解放する仕組みになっている。(閉じカッコ `}` を抜けるとき、Rustはdrop()が呼ばれ、スコープ内の変数のメモリを自動的に解放してくれる！)
    このパターンを、C++ではRAII(Resource Aquisition Is Initialization) と呼ぶらしい

    ---

    */

    let s = String::from("aaaaaaaaaaaaaaaaaa");
    println!("{}", s);
    let hoge = s; // s は無効になる
    println!("{}", hoge);
    // println!("{}", s); sは無効なので、エラー(Moveしたよ)
    // この言語は、本質的に shallow copyを許さない(できない。Moveだけができる)

    // deep copy はある. cloneを使え
    let mut fuga = hoge.clone();
    fuga.push_str("piyo");
    println!("{}", fuga);

    // stackのみのデータはシャローコピーができちゃう
    let x = 5;
    let y = x;
    println!("{}, {}", x, y) // Move できちゃう

    // 整数のようなスタックに収まるようなやつは、実際のコピーも高速だから(?)
    // スタックに収まる変数はshallow と　deepを区別しない
    // つまり、コピーはスタック変数にのみ実現される。ヒープに保持されるやつには、MoveとCloneがある。
    // スタックに保持される型に対して、Copy Trait が適合する。
}
